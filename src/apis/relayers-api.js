/* tslint:disable */
/* eslint-disable */
/**
 * OpenZeppelin Relayer API
 * OpenZeppelin Relayer API
 *
 * The version of the OpenAPI document: 1.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, BaseAPI, operationServerMap } from '../base';
/**
 * RelayersApi - axios parameter creator
 * @export
 */
export const RelayersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint builds a transaction where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency.  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns a prepared transaction that includes: - The transaction XDR (base64 encoded) ready for signing - The fee amount in both the fee token and native currency (stroops for Stellar) - The fee token identifier - The transaction validity timestamp  After receiving the prepared transaction, the user must sign it and submit it through the standard transaction submission endpoint. For Stellar, the transaction will be wrapped in a fee-bump transaction where the relayer pays the network fees.
         * @summary Prepares a sponsored (gasless) transaction with fee payments.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionBuildRequest} sponsoredTransactionBuildRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildSponsoredTransaction: async (relayerId, sponsoredTransactionBuildRequest, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('buildSponsoredTransaction', 'relayerId', relayerId);
            // verify required parameter 'sponsoredTransactionBuildRequest' is not null or undefined
            assertParamExists('buildSponsoredTransaction', 'sponsoredTransactionBuildRequest', sponsoredTransactionBuildRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/sponsored/build`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sponsoredTransactionBuildRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Cancels a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction: async (relayerId, transactionId, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('cancelTransaction', 'relayerId', relayerId);
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('cancelTransaction', 'transactionId', transactionId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/{transaction_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new relayer.
         * @param {CreateRelayerRequest} createRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelayer: async (createRelayerRequest, options = {}) => {
            // verify required parameter 'createRelayerRequest' is not null or undefined
            assertParamExists('createRelayer', 'createRelayerRequest', createRelayerRequest);
            const localVarPath = `/api/v1/relayers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createRelayerRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes all pending transactions for a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePendingTransactions: async (relayerId, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('deletePendingTransactions', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/pending`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayer: async (relayerId, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('deleteRelayer', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieves details of a specific relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayer: async (relayerId, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('getRelayer', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieves the balance of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayerBalance: async (relayerId, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('getRelayerBalance', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/balance`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fetches the current status of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayerStatus: async (relayerId, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('getRelayerStatus', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/status`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint provides fee estimation for transactions where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency (e.g., XLM for Stellar).  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns the estimated fee amount in the specified fee token and the conversion rate from the native currency.
         * @summary Estimates fees for a sponsored (gasless) transaction.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionQuoteRequest} sponsoredTransactionQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSponsoredTransactionQuote: async (relayerId, sponsoredTransactionQuoteRequest, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('getSponsoredTransactionQuote', 'relayerId', relayerId);
            // verify required parameter 'sponsoredTransactionQuoteRequest' is not null or undefined
            assertParamExists('getSponsoredTransactionQuote', 'sponsoredTransactionQuoteRequest', sponsoredTransactionQuoteRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/sponsored/quote`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sponsoredTransactionQuoteRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieves a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById: async (relayerId, transactionId, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('getTransactionById', 'relayerId', relayerId);
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransactionById', 'transactionId', transactionId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/{transaction_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieves a transaction by its nonce value.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} nonce The nonce of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByNonce: async (relayerId, nonce, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('getTransactionByNonce', 'relayerId', relayerId);
            // verify required parameter 'nonce' is not null or undefined
            assertParamExists('getTransactionByNonce', 'nonce', nonce);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/by-nonce/{nonce}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)))
                .replace(`{${"nonce"}}`, encodeURIComponent(String(nonce)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: OpenAPI documentation for these endpoints can be found in the `openapi.rs` file  Lists all relayers with pagination support.
         * @summary Relayer routes implementation
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelayers: async (page, perPage, options = {}) => {
            const localVarPath = `/api/v1/relayers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Lists all transactions for a specific relayer with pagination.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions: async (relayerId, page, perPage, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('listTransactions', 'relayerId', relayerId);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replaces a specific transaction with a new one.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceTransaction: async (relayerId, transactionId, networkTransactionRequest, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('replaceTransaction', 'relayerId', relayerId);
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('replaceTransaction', 'transactionId', transactionId);
            // verify required parameter 'networkTransactionRequest' is not null or undefined
            assertParamExists('replaceTransaction', 'networkTransactionRequest', networkTransactionRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions/{transaction_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(networkTransactionRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Performs a JSON-RPC call using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {JsonRpcRequestNetworkRpcRequest} jsonRpcRequestNetworkRpcRequest JSON-RPC request with method and parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpc: async (relayerId, jsonRpcRequestNetworkRpcRequest, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('rpc', 'relayerId', relayerId);
            // verify required parameter 'jsonRpcRequestNetworkRpcRequest' is not null or undefined
            assertParamExists('rpc', 'jsonRpcRequestNetworkRpcRequest', jsonRpcRequestNetworkRpcRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/rpc`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(jsonRpcRequestNetworkRpcRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Sends a transaction through the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction: async (relayerId, networkTransactionRequest, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('sendTransaction', 'relayerId', relayerId);
            // verify required parameter 'networkTransactionRequest' is not null or undefined
            assertParamExists('sendTransaction', 'networkTransactionRequest', networkTransactionRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/transactions`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(networkTransactionRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Signs data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignDataRequest} signDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign: async (relayerId, signDataRequest, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('sign', 'relayerId', relayerId);
            // verify required parameter 'signDataRequest' is not null or undefined
            assertParamExists('sign', 'signDataRequest', signDataRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/sign`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(signDataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Signs a transaction using the specified relayer (Stellar only).
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTransactionRequest} signTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTransaction: async (relayerId, signTransactionRequest, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('signTransaction', 'relayerId', relayerId);
            // verify required parameter 'signTransactionRequest' is not null or undefined
            assertParamExists('signTransaction', 'signTransactionRequest', signTransactionRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/sign-transaction`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(signTransactionRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Signs typed data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTypedDataRequest} signTypedDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTypedData: async (relayerId, signTypedDataRequest, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('signTypedData', 'relayerId', relayerId);
            // verify required parameter 'signTypedDataRequest' is not null or undefined
            assertParamExists('signTypedData', 'signTypedDataRequest', signTypedDataRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}/sign-typed-data`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(signTypedDataRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a relayer\'s information based on the provided update request.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {UpdateRelayerRequest} updateRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRelayer: async (relayerId, updateRelayerRequest, options = {}) => {
            // verify required parameter 'relayerId' is not null or undefined
            assertParamExists('updateRelayer', 'relayerId', relayerId);
            // verify required parameter 'updateRelayerRequest' is not null or undefined
            assertParamExists('updateRelayer', 'updateRelayerRequest', updateRelayerRequest);
            const localVarPath = `/api/v1/relayers/{relayer_id}`
                .replace(`{${"relayer_id"}}`, encodeURIComponent(String(relayerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer_auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateRelayerRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * RelayersApi - functional programming interface
 * @export
 */
export const RelayersApiFp = function (configuration) {
    const localVarAxiosParamCreator = RelayersApiAxiosParamCreator(configuration);
    return {
        /**
         * This endpoint builds a transaction where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency.  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns a prepared transaction that includes: - The transaction XDR (base64 encoded) ready for signing - The fee amount in both the fee token and native currency (stroops for Stellar) - The fee token identifier - The transaction validity timestamp  After receiving the prepared transaction, the user must sign it and submit it through the standard transaction submission endpoint. For Stellar, the transaction will be wrapped in a fee-bump transaction where the relayer pays the network fees.
         * @summary Prepares a sponsored (gasless) transaction with fee payments.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionBuildRequest} sponsoredTransactionBuildRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.buildSponsoredTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Cancels a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransaction(relayerId, transactionId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransaction(relayerId, transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.cancelTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Creates a new relayer.
         * @param {CreateRelayerRequest} createRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRelayer(createRelayerRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRelayer(createRelayerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.createRelayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Deletes all pending transactions for a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePendingTransactions(relayerId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePendingTransactions(relayerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.deletePendingTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Deletes a relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelayer(relayerId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelayer(relayerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.deleteRelayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Retrieves details of a specific relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelayer(relayerId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelayer(relayerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.getRelayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Retrieves the balance of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelayerBalance(relayerId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelayerBalance(relayerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.getRelayerBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Fetches the current status of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelayerStatus(relayerId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelayerStatus(relayerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.getRelayerStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint provides fee estimation for transactions where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency (e.g., XLM for Stellar).  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns the estimated fee amount in the specified fee token and the conversion rate from the native currency.
         * @summary Estimates fees for a sponsored (gasless) transaction.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionQuoteRequest} sponsoredTransactionQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSponsoredTransactionQuote(relayerId, sponsoredTransactionQuoteRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSponsoredTransactionQuote(relayerId, sponsoredTransactionQuoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.getSponsoredTransactionQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Retrieves a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionById(relayerId, transactionId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionById(relayerId, transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.getTransactionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Retrieves a transaction by its nonce value.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} nonce The nonce of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionByNonce(relayerId, nonce, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionByNonce(relayerId, nonce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.getTransactionByNonce']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Note: OpenAPI documentation for these endpoints can be found in the `openapi.rs` file  Lists all relayers with pagination support.
         * @summary Relayer routes implementation
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRelayers(page, perPage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRelayers(page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.listRelayers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Lists all transactions for a specific relayer with pagination.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactions(relayerId, page, perPage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactions(relayerId, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.listTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Replaces a specific transaction with a new one.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceTransaction(relayerId, transactionId, networkTransactionRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceTransaction(relayerId, transactionId, networkTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.replaceTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Performs a JSON-RPC call using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {JsonRpcRequestNetworkRpcRequest} jsonRpcRequestNetworkRpcRequest JSON-RPC request with method and parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.rpc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Sends a transaction through the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTransaction(relayerId, networkTransactionRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTransaction(relayerId, networkTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.sendTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Signs data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignDataRequest} signDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sign(relayerId, signDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sign(relayerId, signDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.sign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Signs a transaction using the specified relayer (Stellar only).
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTransactionRequest} signTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signTransaction(relayerId, signTransactionRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signTransaction(relayerId, signTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.signTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Signs typed data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTypedDataRequest} signTypedDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signTypedData(relayerId, signTypedDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signTypedData(relayerId, signTypedDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.signTypedData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Updates a relayer\'s information based on the provided update request.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {UpdateRelayerRequest} updateRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRelayer(relayerId, updateRelayerRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRelayer(relayerId, updateRelayerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelayersApi.updateRelayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * RelayersApi - factory interface
 * @export
 */
export const RelayersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = RelayersApiFp(configuration);
    return {
        /**
         * This endpoint builds a transaction where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency.  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns a prepared transaction that includes: - The transaction XDR (base64 encoded) ready for signing - The fee amount in both the fee token and native currency (stroops for Stellar) - The fee token identifier - The transaction validity timestamp  After receiving the prepared transaction, the user must sign it and submit it through the standard transaction submission endpoint. For Stellar, the transaction will be wrapped in a fee-bump transaction where the relayer pays the network fees.
         * @summary Prepares a sponsored (gasless) transaction with fee payments.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionBuildRequest} sponsoredTransactionBuildRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options) {
            return localVarFp.buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Cancels a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransaction(relayerId, transactionId, options) {
            return localVarFp.cancelTransaction(relayerId, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new relayer.
         * @param {CreateRelayerRequest} createRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelayer(createRelayerRequest, options) {
            return localVarFp.createRelayer(createRelayerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes all pending transactions for a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePendingTransactions(relayerId, options) {
            return localVarFp.deletePendingTransactions(relayerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayer(relayerId, options) {
            return localVarFp.deleteRelayer(relayerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves details of a specific relayer by ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayer(relayerId, options) {
            return localVarFp.getRelayer(relayerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves the balance of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayerBalance(relayerId, options) {
            return localVarFp.getRelayerBalance(relayerId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fetches the current status of a specific relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayerStatus(relayerId, options) {
            return localVarFp.getRelayerStatus(relayerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint provides fee estimation for transactions where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency (e.g., XLM for Stellar).  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns the estimated fee amount in the specified fee token and the conversion rate from the native currency.
         * @summary Estimates fees for a sponsored (gasless) transaction.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SponsoredTransactionQuoteRequest} sponsoredTransactionQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSponsoredTransactionQuote(relayerId, sponsoredTransactionQuoteRequest, options) {
            return localVarFp.getSponsoredTransactionQuote(relayerId, sponsoredTransactionQuoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves a specific transaction by its ID.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionById(relayerId, transactionId, options) {
            return localVarFp.getTransactionById(relayerId, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves a transaction by its nonce value.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} nonce The nonce of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionByNonce(relayerId, nonce, options) {
            return localVarFp.getTransactionByNonce(relayerId, nonce, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: OpenAPI documentation for these endpoints can be found in the `openapi.rs` file  Lists all relayers with pagination support.
         * @summary Relayer routes implementation
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelayers(page, perPage, options) {
            return localVarFp.listRelayers(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Lists all transactions for a specific relayer with pagination.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [perPage] Number of items per page (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactions(relayerId, page, perPage, options) {
            return localVarFp.listTransactions(relayerId, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Replaces a specific transaction with a new one.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {string} transactionId The unique identifier of the transaction
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceTransaction(relayerId, transactionId, networkTransactionRequest, options) {
            return localVarFp.replaceTransaction(relayerId, transactionId, networkTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Performs a JSON-RPC call using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {JsonRpcRequestNetworkRpcRequest} jsonRpcRequestNetworkRpcRequest JSON-RPC request with method and parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options) {
            return localVarFp.rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Sends a transaction through the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {NetworkTransactionRequest} networkTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTransaction(relayerId, networkTransactionRequest, options) {
            return localVarFp.sendTransaction(relayerId, networkTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Signs data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignDataRequest} signDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign(relayerId, signDataRequest, options) {
            return localVarFp.sign(relayerId, signDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Signs a transaction using the specified relayer (Stellar only).
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTransactionRequest} signTransactionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTransaction(relayerId, signTransactionRequest, options) {
            return localVarFp.signTransaction(relayerId, signTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Signs typed data using the specified relayer.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {SignTypedDataRequest} signTypedDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTypedData(relayerId, signTypedDataRequest, options) {
            return localVarFp.signTypedData(relayerId, signTypedDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a relayer\'s information based on the provided update request.
         * @param {string} relayerId The unique identifier of the relayer
         * @param {UpdateRelayerRequest} updateRelayerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRelayer(relayerId, updateRelayerRequest, options) {
            return localVarFp.updateRelayer(relayerId, updateRelayerRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RelayersApi - object-oriented interface
 * @export
 * @class RelayersApi
 * @extends {BaseAPI}
 */
export class RelayersApi extends BaseAPI {
    /**
     * This endpoint builds a transaction where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency.  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns a prepared transaction that includes: - The transaction XDR (base64 encoded) ready for signing - The fee amount in both the fee token and native currency (stroops for Stellar) - The fee token identifier - The transaction validity timestamp  After receiving the prepared transaction, the user must sign it and submit it through the standard transaction submission endpoint. For Stellar, the transaction will be wrapped in a fee-bump transaction where the relayer pays the network fees.
     * @summary Prepares a sponsored (gasless) transaction with fee payments.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {SponsoredTransactionBuildRequest} sponsoredTransactionBuildRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options) {
        return RelayersApiFp(this.configuration).buildSponsoredTransaction(relayerId, sponsoredTransactionBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Cancels a specific transaction by its ID.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {string} transactionId The unique identifier of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    cancelTransaction(relayerId, transactionId, options) {
        return RelayersApiFp(this.configuration).cancelTransaction(relayerId, transactionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new relayer.
     * @param {CreateRelayerRequest} createRelayerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    createRelayer(createRelayerRequest, options) {
        return RelayersApiFp(this.configuration).createRelayer(createRelayerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes all pending transactions for a specific relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    deletePendingTransactions(relayerId, options) {
        return RelayersApiFp(this.configuration).deletePendingTransactions(relayerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a relayer by ID.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    deleteRelayer(relayerId, options) {
        return RelayersApiFp(this.configuration).deleteRelayer(relayerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves details of a specific relayer by ID.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getRelayer(relayerId, options) {
        return RelayersApiFp(this.configuration).getRelayer(relayerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves the balance of a specific relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getRelayerBalance(relayerId, options) {
        return RelayersApiFp(this.configuration).getRelayerBalance(relayerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fetches the current status of a specific relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getRelayerStatus(relayerId, options) {
        return RelayersApiFp(this.configuration).getRelayerStatus(relayerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint provides fee estimation for transactions where the relayer will pay the network fees on behalf of the user. The user pays fees in a token of their choice (e.g., USDC) instead of the native network currency (e.g., XLM for Stellar).  The endpoint accepts either a pre-built transaction XDR or a set of operations to build a transaction from. It returns the estimated fee amount in the specified fee token and the conversion rate from the native currency.
     * @summary Estimates fees for a sponsored (gasless) transaction.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {SponsoredTransactionQuoteRequest} sponsoredTransactionQuoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getSponsoredTransactionQuote(relayerId, sponsoredTransactionQuoteRequest, options) {
        return RelayersApiFp(this.configuration).getSponsoredTransactionQuote(relayerId, sponsoredTransactionQuoteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves a specific transaction by its ID.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {string} transactionId The unique identifier of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getTransactionById(relayerId, transactionId, options) {
        return RelayersApiFp(this.configuration).getTransactionById(relayerId, transactionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves a transaction by its nonce value.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {number} nonce The nonce of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    getTransactionByNonce(relayerId, nonce, options) {
        return RelayersApiFp(this.configuration).getTransactionByNonce(relayerId, nonce, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Note: OpenAPI documentation for these endpoints can be found in the `openapi.rs` file  Lists all relayers with pagination support.
     * @summary Relayer routes implementation
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [perPage] Number of items per page (default: 10)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    listRelayers(page, perPage, options) {
        return RelayersApiFp(this.configuration).listRelayers(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Lists all transactions for a specific relayer with pagination.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [perPage] Number of items per page (default: 10)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    listTransactions(relayerId, page, perPage, options) {
        return RelayersApiFp(this.configuration).listTransactions(relayerId, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Replaces a specific transaction with a new one.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {string} transactionId The unique identifier of the transaction
     * @param {NetworkTransactionRequest} networkTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    replaceTransaction(relayerId, transactionId, networkTransactionRequest, options) {
        return RelayersApiFp(this.configuration).replaceTransaction(relayerId, transactionId, networkTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Performs a JSON-RPC call using the specified relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {JsonRpcRequestNetworkRpcRequest} jsonRpcRequestNetworkRpcRequest JSON-RPC request with method and parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options) {
        return RelayersApiFp(this.configuration).rpc(relayerId, jsonRpcRequestNetworkRpcRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Sends a transaction through the specified relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {NetworkTransactionRequest} networkTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    sendTransaction(relayerId, networkTransactionRequest, options) {
        return RelayersApiFp(this.configuration).sendTransaction(relayerId, networkTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Signs data using the specified relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {SignDataRequest} signDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    sign(relayerId, signDataRequest, options) {
        return RelayersApiFp(this.configuration).sign(relayerId, signDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Signs a transaction using the specified relayer (Stellar only).
     * @param {string} relayerId The unique identifier of the relayer
     * @param {SignTransactionRequest} signTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    signTransaction(relayerId, signTransactionRequest, options) {
        return RelayersApiFp(this.configuration).signTransaction(relayerId, signTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Signs typed data using the specified relayer.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {SignTypedDataRequest} signTypedDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    signTypedData(relayerId, signTypedDataRequest, options) {
        return RelayersApiFp(this.configuration).signTypedData(relayerId, signTypedDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a relayer\'s information based on the provided update request.
     * @param {string} relayerId The unique identifier of the relayer
     * @param {UpdateRelayerRequest} updateRelayerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayersApi
     */
    updateRelayer(relayerId, updateRelayerRequest, options) {
        return RelayersApiFp(this.configuration).updateRelayer(relayerId, updateRelayerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
